//! SeaORM Entity. Generated by sea-orm-codegen 0.9.3

use crate::config::RuntimeConfig;
use crate::database::DbResult;
use crate::utils::hashing::hash_password;
use futures_util::future::BoxFuture;
use sea_orm::prelude::*;
use sea_orm::{
    ActiveModelTrait, ActiveValue::Set, ColumnTrait, DatabaseConnection, DeleteResult, EntityTrait,
    IntoActiveModel, QueryFilter,
};
use serde::{Deserialize, Serialize};
use std::future::Future;

#[derive(Serialize, Clone, Debug, PartialEq, Eq, DeriveEntityModel)]
#[sea_orm(table_name = "players")]
pub struct Model {
    /// Unique Identifier for the player
    #[sea_orm(primary_key)]
    pub id: u32,
    /// Email address of the player
    pub email: String,
    /// Display name / Username of the player
    pub display_name: String,
    /// Hashed password which is omitted from serialization
    #[serde(skip)]
    pub password: Option<String>,
    /// The role of the player
    pub role: PlayerRole,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::leaderboard_data::Entity")]
    LeaderboardData,
}

// `Related` trait has to be implemented by hand
impl Related<super::leaderboard_data::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::LeaderboardData.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

/// Enum for the different roles that a player could have used to
/// determine their permissions to access different server
/// functionality
#[derive(
    Deserialize,
    Serialize,
    Debug,
    Clone,
    Copy,
    PartialEq,
    PartialOrd,
    Ord,
    Eq,
    EnumIter,
    DeriveActiveEnum,
)]
#[sea_orm(rs_type = "u8", db_type = "TinyUnsigned")]
#[repr(u8)]
pub enum PlayerRole {
    /// The default no extra permissions level
    #[sea_orm(num_value = 0)]
    Default = 0,

    /// Administrator role which can be added and removed by
    /// super admin.
    #[sea_orm(num_value = 1)]
    Admin = 1,

    /// Super admin role which is created on startup and used to
    /// manage other user roles
    #[sea_orm(num_value = 2)]
    SuperAdmin = 2,
}

impl Model {
    /// Creates a new player with the proivded details and inserts
    /// it into the database
    ///
    /// `db`           The database instance
    /// `email`        The player account email
    /// `display_name` The player display name
    /// `password`     The hashed player password
    /// `origin`       Whether the account is an origin account
    pub fn create<'db>(
        db: &'db DatabaseConnection,
        email: String,
        display_name: String,
        mut password: Option<String>,
        config: &RuntimeConfig,
    ) -> BoxFuture<'db, DbResult<Self>> {
        let mut role = PlayerRole::Default;

        if config
            .dashboard
            .super_email
            .as_ref()
            .is_some_and(|super_email| super_email == &email)
        {
            role = PlayerRole::SuperAdmin;

            // Don't override the password if they're created form the dashboard
            if password.is_none() {
                if let Some(super_password) = config.dashboard.super_password.as_ref() {
                    let password_hash =
                        hash_password(super_password).expect("Failed to hash super user password");

                    password = Some(password_hash);
                }
            }
        }

        let active_model = ActiveModel {
            email: Set(email),
            display_name: Set(display_name),
            password: Set(password),
            role: Set(role),
            ..Default::default()
        };
        active_model.insert(db)
    }

    /// Deletes the provided player
    ///
    /// `db` The database connection
    pub fn delete(self, db: &DatabaseConnection) -> BoxFuture<DbResult<DeleteResult>> {
        // Delete player itself
        let model = self.into_active_model();
        model.delete(db)
    }

    /// Attempts to find a player with the provided ID will return none
    /// if there was no players with that ID
    ///
    /// `db` The database instance
    /// `id` The ID of the player to find
    pub fn by_id(
        db: &DatabaseConnection,
        id: u32,
    ) -> impl Future<Output = DbResult<Option<Self>>> + Send + '_ {
        Entity::find_by_id(id).one(db)
    }

    /// Attempts to find a player with the provided email.
    ///
    /// `db`    The database connection
    /// `email` The email address to search for
    pub fn by_email<'a>(
        db: &'a DatabaseConnection,
        email: &str,
    ) -> impl Future<Output = DbResult<Option<Self>>> + Send + 'a {
        Entity::find().filter(Column::Email.eq(email)).one(db)
    }

    /// Determines whether the current player has permission to
    /// make actions on behalf of the other player. This can
    /// occur when they are both the same player or the role of
    /// self is greater than the other role
    ///
    /// `other` The player to check for permission over
    pub fn has_permission_over(&self, other: &Self) -> bool {
        self.id == other.id || self.role > other.role
    }

    /// Determines whether a player can delete another player.
    /// Ensures that the role is greater and that the IDs are
    /// not equal
    ///
    /// `other` The player to check for permission over
    pub fn can_delete(&self, other: &Self) -> bool {
        self.id != other.id && self.role > other.role
    }

    /// Updates the password for the provided player returning
    /// a future resolving to the new player with its updated
    /// password value
    ///
    /// `db`       The database connection
    /// `password` The new hashed password
    pub fn set_password(
        self,
        db: &DatabaseConnection,
        password: String,
    ) -> BoxFuture<'_, DbResult<Self>> {
        let mut model = self.into_active_model();
        model.password = Set(Some(password));
        model.update(db)
    }

    /// Sets the role of the provided player
    ///
    /// `db`   The database connection
    /// `role` The new role for the player
    pub fn set_role(
        self,
        db: &DatabaseConnection,
        role: PlayerRole,
    ) -> BoxFuture<'_, DbResult<Self>> {
        let mut model = self.into_active_model();
        model.role = Set(role);
        model.update(db)
    }

    /// Updates the basic details of the provided player if
    /// they are provided
    ///
    /// `db`       The database connection
    /// `username` Optional new username for the player
    /// `email`    Optional new email for the player
    pub fn set_details(
        self,
        db: &DatabaseConnection,
        username: Option<String>,
        email: Option<String>,
    ) -> BoxFuture<'_, DbResult<Self>> {
        let mut model = self.into_active_model();

        if let Some(username) = username {
            model.display_name = Set(username);
        }

        if let Some(email) = email {
            model.email = Set(email)
        }

        model.update(db)
    }
}
